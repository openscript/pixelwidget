substitutions:
  device: pixelwidget
  name: pixelwidget
  friendly_name: Pixel Widget

  # Ulanzi TC001 pin definitions
  battery_pin: GPIO34
  ldr_pin: GPIO35
  matrix_pin: GPIO32
  buzzer_pin: GPIO15
  left_button_pin: GPIO26
  mid_button_pin: GPIO27
  right_button_pin: GPIO14
  scl_pin: GPIO22
  sda_pin: GPIO21
  # Optional webhook URL (empty means disabled)
  send_image_webhook_url: !secret send_image_webhook_url
  send_image_webhook_token: !secret send_image_webhook_token

esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  on_boot:
    priority: -100
    then:
      - lambda: id(buzzer_out).turn_off();
      - script.execute:
          id: wake_display
          timeout_minutes: 15

# Global variables for display sleep/wake
globals:
  - id: display_timeout_minutes
    type: int
    restore_value: no
    initial_value: '15'
  - id: display_brightness
    type: float
    restore_value: yes
    initial_value: '0.33'
  - id: display_is_awake
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: first_led_r
    type: int
    restore_value: no
    initial_value: '0'
  - id: first_led_g
    type: int
    restore_value: no
    initial_value: '0'
  - id: first_led_b
    type: int
    restore_value: no
    initial_value: '0'

# Scripts for display management
script:
  - id: wake_display
    mode: restart
    parameters:
      timeout_minutes: int
    then:
      - lambda: |-
          id(display_timeout_minutes) = timeout_minutes;
          ESP_LOGI("display", "Display wake, timeout in %d minutes, brightness %.0f%%", timeout_minutes, id(display_brightness) * 100);
          // Only push brightness the first time after sleep to avoid visible flicker
          if (!id(display_is_awake)) {
            id(display_is_awake) = true;
            auto call = id(matrix_light).make_call();
            call.set_brightness(id(display_brightness));
            call.perform();
          }
      - delay: !lambda 'return id(display_timeout_minutes) * 60 * 1000;'
      - lambda: |-
          // Sleep by setting brightness to 0
          auto call = id(matrix_light).make_call();
          call.set_brightness(0.0f);
          call.perform();
          id(display_is_awake) = false;
          ESP_LOGI("display", "Display sleep after timeout");

  - id: trigger_webhook
    mode: single
    then:
      - if:
          condition:
            lambda: 'return strlen("${send_image_webhook_url}") > 0;'
          then:
            - lambda: |-
                ESP_LOGI("http", "Triggering webhook to request image");
            - http_request.post:
                url: "${send_image_webhook_url}"
                request_headers:
                  Authorization: "Bearer ${send_image_webhook_token}"
                  Content-Type: "application/json"
                body: '{"name":"Functions"}'
                on_response:
                  then:
                    - lambda: |-
                        ESP_LOGI("http", "Image request completed with status code: %d", response->status_code);
          else:
            - lambda: |-
                ESP_LOGW("http", "send_image_webhook_url not configured");

  - id: show_status_indicator
    mode: restart
    then:
      # Read and backup LED 0 state directly from the light output
      - lambda: |-
          // Access the internal buffer through the AddressableLight interface
          auto *addressable = static_cast<esphome::light::AddressableLight*>(
            id(matrix_light).get_output()
          );

          if (addressable != nullptr) {
            // Use the operator[] to get the color at position 0
            auto color_view = (*addressable)[0];
            id(first_led_r) = color_view.get_red();
            id(first_led_g) = color_view.get_green();
            id(first_led_b) = color_view.get_blue();
            ESP_LOGI("status", "Backed up LED 0: R=%d G=%d B=%d",
                     id(first_led_r), id(first_led_g), id(first_led_b));
          }

      # Show status color
      - lambda: |-
          Color status_color;

          if (!id(wifi_component).is_connected()) {
            status_color = Color(255, 0, 0);
            ESP_LOGI("status", "Status: No WiFi (RED)");
          } else if (!id(mqtt_client).is_connected()) {
            status_color = Color(255, 128, 0);
            ESP_LOGI("status", "Status: WiFi only (ORANGE)");
          } else {
            status_color = Color(0, 255, 0);
            ESP_LOGI("status", "Status: Connected (GREEN)");
          }

          id(matrix_display).draw_pixel_at(0, 0, status_color);

      # Wait 3 seconds
      - delay: 3s

      # Restore original LED state
      - lambda: |-
          Color backup = Color(id(first_led_r), id(first_led_g), id(first_led_b));
          id(matrix_display).draw_pixel_at(0, 0, backup);
          ESP_LOGI("status", "Restored LED 0: R=%d G=%d B=%d",
                   id(first_led_r), id(first_led_g), id(first_led_b));

# Add interval to trigger status indicator every 30 seconds
interval:
  - interval: 30s
    then:
      - script.execute: show_status_indicator

esp32:
  board: esp32dev
  framework:
    type: esp-idf

logger:
  level: INFO

http_request:
  useragent: esphome/pixelwidget
  timeout: 10s
  verify_ssl: true

api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  id: wifi_component
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "PixelWidget-Fallback"
    password: !secret ap_password

captive_portal:

mqtt:
  id: mqtt_client
  broker: !secret mqtt_broker
  port: !secret mqtt_port
  username: !secret mqtt_username
  password: !secret mqtt_password
  client_id: ${name}
  certificate_authority: |
    -----BEGIN CERTIFICATE-----
    MIIFazCCA1OgAwIBAgIRAIIQz7DSQONZRGPgu2OCiwAwDQYJKoZIhvcNAQELBQAw
    TzELMAkGA1UEBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2Vh
    cmNoIEdyb3VwMRUwEwYDVQQDEwxJU1JHIFJvb3QgWDEwHhcNMTUwNjA0MTEwNDM4
    WhcNMzUwNjA0MTEwNDM4WjBPMQswCQYDVQQGEwJVUzEpMCcGA1UEChMgSW50ZXJu
    ZXQgU2VjdXJpdHkgUmVzZWFyY2ggR3JvdXAxFTATBgNVBAMTDElTUkcgUm9vdCBY
    MTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK3oJHP0FDfzm54rVygc
    h77ct984kIxuPOZXoHj3dcKi/vVqbvYATyjb3miGbESTtrFj/RQSa78f0uoxmyF+
    0TM8ukj13Xnfs7j/EvEhmkvBioZxaUpmZmyPfjxwv60pIgbz5MDmgK7iS4+3mX6U
    A5/TR5d8mUgjU+g4rk8Kb4Mu0UlXjIB0ttov0DiNewNwIRt18jA8+o+u3dpjq+sW
    T8KOEUt+zwvo/7V3LvSye0rgTBIlDHCNAymg4VMk7BPZ7hm/ELNKjD+Jo2FR3qyH
    B5T0Y3HsLuJvW5iB4YlcNHlsdu87kGJ55tukmi8mxdAQ4Q7e2RCOFvu396j3x+UC
    B5iPNgiV5+I3lg02dZ77DnKxHZu8A/lJBdiB3QW0KtZB6awBdpUKD9jf1b0SHzUv
    KBds0pjBqAlkd25HN7rOrFleaJ1/ctaJxQZBKT5ZPt0m9STJEadao0xAH0ahmbWn
    OlFuhjuefXKnEgV4We0+UXgVCwOPjdAvBbI+e0ocS3MFEvzG6uBQE3xDk3SzynTn
    jh8BCNAw1FtxNrQHusEwMFxIt4I7mKZ9YIqioymCzLq9gwQbooMDQaHWBfEbwrbw
    qHyGO0aoSCqI3Haadr8faqU9GY/rOPNk3sgrDQoo//fb4hVC1CLQJ13hef4Y53CI
    rU7m2Ys6xt0nUW7/vGT1M0NPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV
    HRMBAf8EBTADAQH/MB0GA1UdDgQWBBR5tFnme7bl5AFzgAiIyBpY9umbbjANBgkq
    hkiG9w0BAQsFAAOCAgEAVR9YqbyyqFDQDLHYGmkgJykIrGF1XIpu+ILlaS/V9lZL
    ubhzEFnTIZd+50xx+7LSYK05qAvqFyFWhfFQDlnrzuBZ6brJFe+GnY+EgPbk6ZGQ
    3BebYhtF8GaV0nxvwuo77x/Py9auJ/GpsMiu/X1+mvoiBOv/2X/qkSsisRcOj/KK
    NFtY2PwByVS5uCbMiogziUwthDyC3+6WVwW6LLv3xLfHTjuCvjHIInNzktHCgKQ5
    ORAzI4JMPJ+GslWYHb4phowim57iaztXOoJwTdwJx4nLCgdNbOhdjsnvzqvHu7Ur
    TkXWStAmzOVyyghqpZXjFaH3pO3JLF+l+/+sKAIuvtd7u+Nxe5AW0wdeRlN8NwdC
    jNPElpzVmbUq4JUagEiuTDkHzsxHpFKVK7q4+63SM1N95R1NbdWhscdCb+ZAJzVc
    oyi3B43njTOQ5yOf+1CceWxG1bQVs5ZufpsMljq4Ui0/1lvh+wjChP4kqKOJ2qxq
    4RgqsahDYVvTH9w7jXbyLeiNdd8XM2w9U/t7y0Ff/9yi0GE44Za4rF2LN9d11TPA
    mRGunUHBcnWEvgJBQl9nJEiU0Zsnvgc/ubhPgXRR4Xq37Z0j4r7g1SgEEzwxA57d
    emyPxgcYxn/eR44/KJ4EBs+lVDR3veyJm+kXQ99b21/+jh5Xos1AnX5iItreGCc=
    -----END CERTIFICATE-----
  birth_message:
    topic: ${name}/status
    payload: online
  will_message:
    topic: ${name}/status
    payload: offline
  on_connect:
    then:
      - delay: 1s
      - mqtt.publish:
          topic: ${name}/image/request
          payload: "1"
      - script.execute: trigger_webhook
      - lambda: ESP_LOGI("mqtt", "Connected - requesting image");

i2c:
  sda: $sda_pin
  scl: $scl_pin
  scan: true

# NeoPixel LED strip - 256 LEDs (32x8 matrix)
light:
  - platform: esp32_rmt_led_strip
    id: matrix_light
    rgb_order: GRB
    pin: $matrix_pin
    num_leds: 256
    chipset: WS2812
    name: "Matrix Light"
    restore_mode: ALWAYS_ON
    default_transition_length: 0s

# Addressable light display for 2D pixel control
display:
  - platform: addressable_light
    id: matrix_display
    addressable_light_id: matrix_light
    width: 32
    height: 8
    pixel_mapper: |-
      if (y % 2 == 0) {
        return (y * 32) + x;
      }
      return (y * 32) + (31 - x);
    rotation: 0Â°
    update_interval: 16ms
    auto_clear_enabled: false
    lambda: |-
      // Display buffer is managed by MQTT commands
      // This lambda could be used for animations if needed

# MQTT command handlers for pixel control
text_sensor:
  # Set single pixel: "x,y,r,g,b"
  - platform: mqtt_subscribe
    name: "Pixel Set"
    id: pixel_set_cmd
    topic: ${name}/pixel/set
    on_value:
      then:
        - script.execute:
            id: wake_display
            timeout_minutes: 15
        - lambda: |-
            int px, py, r, g, b;
            if (sscanf(x.c_str(), "%d,%d,%d,%d,%d", &px, &py, &r, &g, &b) == 5) {
              if (px >= 0 && px < 32 && py >= 0 && py < 8) {
                id(matrix_display).draw_pixel_at(px, py, Color(r, g, b));
                ESP_LOGI("pixel", "Set (%d,%d) to RGB(%d,%d,%d)", px, py, r, g, b);
              }
            }

  # Fill entire display: "r,g,b"
  - platform: mqtt_subscribe
    name: "Pixel Fill"
    id: pixel_fill_cmd
    topic: ${name}/pixel/fill
    on_value:
      then:
        - script.execute:
            id: wake_display
            timeout_minutes: 15
        - lambda: |-
            int r, g, b;
            if (sscanf(x.c_str(), "%d,%d,%d", &r, &g, &b) == 3) {
              id(matrix_display).fill(Color(r, g, b));
              ESP_LOGI("pixel", "Fill RGB(%d,%d,%d)", r, g, b);
            }

  # Clear display (set all pixels to black)
  - platform: mqtt_subscribe
    name: "Pixel Clear"
    id: pixel_clear_cmd
    topic: ${name}/pixel/clear
    on_value:
      then:
        - script.execute:
            id: wake_display
            timeout_minutes: 15
        - lambda: |-
            id(matrix_display).fill(Color(0, 0, 0));
            ESP_LOGI("pixel", "Clear display");

  # Draw line: "x1,y1,x2,y2,r,g,b"
  - platform: mqtt_subscribe
    name: "Pixel Line"
    id: pixel_line_cmd
    topic: ${name}/pixel/line
    on_value:
      then:
        - script.execute:
            id: wake_display
            timeout_minutes: 15
        - lambda: |-
            int x1, y1, x2, y2, r, g, b;
            if (sscanf(x.c_str(), "%d,%d,%d,%d,%d,%d,%d", &x1, &y1, &x2, &y2, &r, &g, &b) == 7) {
              id(matrix_display).line(x1, y1, x2, y2, Color(r, g, b));
              ESP_LOGI("pixel", "Line (%d,%d)-(%d,%d) RGB(%d,%d,%d)", x1, y1, x2, y2, r, g, b);
            }

  # Draw rectangle: "x,y,w,h,r,g,b"
  - platform: mqtt_subscribe
    name: "Pixel Rect"
    id: pixel_rect_cmd
    topic: ${name}/pixel/rect
    on_value:
      then:
        - script.execute:
            id: wake_display
            timeout_minutes: 15
        - lambda: |-
            int px, py, w, h, r, g, b;
            if (sscanf(x.c_str(), "%d,%d,%d,%d,%d,%d,%d", &px, &py, &w, &h, &r, &g, &b) == 7) {
              id(matrix_display).rectangle(px, py, w, h, Color(r, g, b));
              ESP_LOGI("pixel", "Rect (%d,%d) %dx%d RGB(%d,%d,%d)", px, py, w, h, r, g, b);
            }

  # Draw filled rectangle: "x,y,w,h,r,g,b"
  - platform: mqtt_subscribe
    name: "Pixel Fill Rect"
    id: pixel_fillrect_cmd
    topic: ${name}/pixel/fillrect
    on_value:
      then:
        - script.execute:
            id: wake_display
            timeout_minutes: 15
        - lambda: |-
            int px, py, w, h, r, g, b;
            if (sscanf(x.c_str(), "%d,%d,%d,%d,%d,%d,%d", &px, &py, &w, &h, &r, &g, &b) == 7) {
              id(matrix_display).filled_rectangle(px, py, w, h, Color(r, g, b));
              ESP_LOGI("pixel", "Filled rect (%d,%d) %dx%d RGB(%d,%d,%d)", px, py, w, h, r, g, b);
            }

  # Set brightness: "0-255"
  - platform: mqtt_subscribe
    name: "Brightness"
    id: brightness_cmd
    topic: ${name}/brightness
    on_value:
      then:
        - lambda: |-
            int brightness;
            if (sscanf(x.c_str(), "%d", &brightness) == 1) {
              float b = brightness / 255.0f;
              id(display_brightness) = b;
              auto call = id(matrix_light).make_call();
              call.set_state(true);
              call.set_brightness(b);
              call.perform();
              ESP_LOGI("pixel", "Brightness %d (%.2f) - saved", brightness, b);
            }

  # Set entire display image: base64 encoded RGB data (256 pixels * 3 bytes = 768 bytes)
  - platform: mqtt_subscribe
    name: "Pixel Image"
    id: pixel_image_cmd
    topic: ${name}/pixel/image
    on_value:
      then:
        - script.execute:
            id: wake_display
            timeout_minutes: 15
        - lambda: |-
            // Decode base64 RGB image data (32x8 = 256 pixels, 3 bytes each = 768 bytes)
            const char* b64 = x.c_str();
            size_t b64_len = x.length();

            // Base64 decode lookup table
            static const uint8_t b64_table[256] = {
              64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
              64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
              64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
              52,53,54,55,56,57,58,59,60,61,64,64,64,0,64,64,
              64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,
              15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,
              64,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,
              41,42,43,44,45,46,47,48,49,50,51,64,64,64,64,64,
              64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
              64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
              64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
              64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
              64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
              64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
              64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
              64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64
            };

            // Decode base64 to RGB buffer
            uint8_t rgb[768];
            size_t rgb_idx = 0;
            uint32_t accum = 0;
            int bits = 0;

            for (size_t i = 0; i < b64_len && rgb_idx < 768; i++) {
              uint8_t val = b64_table[(uint8_t)b64[i]];
              if (val < 64) {
                accum = (accum << 6) | val;
                bits += 6;
                while (bits >= 8 && rgb_idx < 768) {
                  bits -= 8;
                  rgb[rgb_idx++] = (accum >> bits) & 0xFF;
                }
              }
            }

            if (rgb_idx >= 768) {
              // Draw all 256 pixels (32x8)
              for (int py = 0; py < 8; py++) {
                for (int px = 0; px < 32; px++) {
                  int idx = (py * 32 + px) * 3;
                  id(matrix_display).draw_pixel_at(px, py, Color(rgb[idx], rgb[idx+1], rgb[idx+2]));
                }
              }
              ESP_LOGI("pixel", "Image received (%d bytes decoded)", rgb_idx);
            } else {
              ESP_LOGW("pixel", "Image incomplete: expected 768 bytes, got %d", rgb_idx);
            }

# Buzzer output (active low, must be turned off on boot)
output:
  - platform: ledc
    pin:
      number: $buzzer_pin
      ignore_strapping_warning: true
    id: buzzer_out

# Buttons for manual control
binary_sensor:
  - platform: gpio
    pin:
      number: $left_button_pin
      inverted: true
    name: "Left Button"
    on_press:
      then:
        - mqtt.publish:
            topic: ${name}/button
            payload: "left"

  - platform: gpio
    pin:
      number: $mid_button_pin
      inverted: true
      mode: INPUT_PULLUP
    name: "Middle Button"
    on_press:
      then:
        - script.execute:
            id: wake_display
            timeout_minutes: 5
        - mqtt.publish:
            topic: ${name}/button
            payload: "middle"
        - mqtt.publish:
            topic: ${name}/image/request
            payload: "1"
        - script.execute: trigger_webhook

  - platform: gpio
    pin:
      number: $right_button_pin
      inverted: true
    name: "Right Button"
    on_press:
      then:
        - mqtt.publish:
            topic: ${name}/button
            payload: "right"

# Sensors
sensor:
  - platform: adc
    pin: $battery_pin
    name: "Battery"
    update_interval: 60s
    attenuation: auto
    filters:
      - multiply: 1.6
      - lambda: |-
          auto r = ((x - 3) / 0.69 * 100.00);
          if (r >= 100) return 100;
          if (r > 0) return r;
          return 0;
    unit_of_measurement: '%'
    device_class: battery

  - platform: adc
    pin: $ldr_pin
    name: "Illuminance"
    update_interval: 10s
    attenuation: auto
    unit_of_measurement: lx
    device_class: illuminance

button:
  - platform: restart
    name: "Restart"

  - platform: template
    name: "Request Image"
    on_press:
      - script.execute: trigger_webhook
